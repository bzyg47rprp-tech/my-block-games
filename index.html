<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>私のブロックゲーム</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: #111; color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overscroll-behavior: none;
    }
    .wrap {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 10px;
      padding: 12px 10px;
      box-sizing: border-box;
    }
    .hud {
      width: min(96vw, 900px);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      opacity: .95;
      font-size: 20px;
      line-height: 1.2;
    }
    .hud .small { opacity: .75; font-size: 16px; margin-top: 6px; }
    canvas {
      display: block;
      width: min(96vw, 900px);
      height: auto;
      aspect-ratio: 4 / 3;
      background: #0b0b0b;
      border: 1px solid #333;
      border-radius: 12px;
      touch-action: none;
    }
    .hint {
      width: min(96vw, 900px);
      text-align: center;
      opacity: .65;
      font-size: 14px;
      padding-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <div id="scoreText">Score: 0</div>
        <div class="small" id="infoText">Kills: 0 / Power: -</div>
      </div>
      <div class="right" style="text-align:right;">
        <div id="lifeText">Life: 3</div>
        <div class="small" id="waveText">Wave: 1</div>
      </div>
    </div>

    <canvas id="game" width="800" height="600"></canvas>

    <div class="hint">操作：ドラッグ / キー(A,D or ←→)。GameOver後：タップ or R</div>
  </div>

  <script>
    // =========================
    // 基本（固定座標 800x600）
    // =========================
    const GAME_W = 800, GAME_H = 600;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreText = document.getElementById("scoreText");
    const infoText  = document.getElementById("infoText");
    const lifeText  = document.getElementById("lifeText");
    const waveText  = document.getElementById("waveText");

    // DPR（ぼやけ防止）＋CSSはスマホフィット
    function applyDPR() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      canvas.width  = Math.floor(GAME_W * dpr);
      canvas.height = Math.floor(GAME_H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    applyDPR();
    window.addEventListener("resize", applyDPR);

    // =========================
    // 状態
    // =========================
    let score = 0;
    let kills = 0;
    let life  = 3;
    let wave  = 1;
    let gameOver = false;

    let lastTime = performance.now();

    const paddle = {
      baseW: 140,
      w: 140,
      h: 14,
      x: (GAME_W - 140) / 2,
      y: GAME_H - 60,
      speed: 520,
    };

    let balls = [];
    let blocks = [];
    let drops = [];

    let powerName = "-";
    let paddleBoostTimer = 0;

    // ブロックの見た目/配置（基本値）
    const BR = {
      w: 24,         // 1セルの横幅（パターン用）
      h: 14,         // 1セルの縦幅（パターン用）
      gap: 3,
      top: 70
    };

    // =========================
    // 入力
    // =========================
    const keys = {};
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys[k] = true;
      if (gameOver && k === "r") restart();
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // ドラッグ操作（パドル追従）
    let dragging = false;

    function canvasToWorld(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (GAME_W / rect.width);
      const y = (clientY - rect.top)  * (GAME_H / rect.height);
      return { x, y };
    }

    function setPaddleByX(x) {
      paddle.x = x - paddle.w / 2;
      clampPaddle();
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      if (gameOver) { restart(); return; }
      dragging = true;
      const p = canvasToWorld(e.clientX, e.clientY);
      setPaddleByX(p.x);
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const p = canvasToWorld(e.clientX, e.clientY);
      setPaddleByX(p.x);
    });

    canvas.addEventListener("pointerup", () => dragging = false);
    canvas.addEventListener("pointercancel", () => dragging = false);

    // =========================
    // 便利
    // =========================
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function clampPaddle() {
      paddle.x = clamp(paddle.x, 0, GAME_W - paddle.w);
    }

    function updateHUD() {
      scoreText.textContent = "Score: " + score;
      infoText.textContent  = "Kills: " + kills + " / Power: " + (powerName || "-");
      lifeText.textContent  = "Life: " + life;
      waveText.textContent  = "Wave: " + wave;
    }

    // =========================
    // ボール/ブロック生成
    // =========================
    function spawnBall() {
      const baseSpeed = 420 + wave * 18; // waveで少し速く
      const dir = Math.random() < 0.5 ? -1 : 1;
      balls.push({
        x: paddle.x + paddle.w / 2,
        y: paddle.y - 12,
        r: 10,
        vx: dir * (baseSpeed * 0.45),
        vy: -baseSpeed * 0.75,
        alive: true
      });
    }

    // pattern（"0/1"の文字列配列）からブロックを作る
    function makePatternBlocks(pattern) {
      const rows = pattern.length;
      const cols = Math.max(...pattern.map(s => s.length));

      // 画面中央寄せ
      const totalW = cols * (BR.w + BR.gap) - BR.gap;
      const left = (GAME_W - totalW) / 2;

      for (let r = 0; r < rows; r++) {
        const line = pattern[r];
        for (let c = 0; c < line.length; c++) {
          if (line[c] !== "1") continue;
          blocks.push({
            x: left + c * (BR.w + BR.gap),
            y: BR.top + r * (BR.h + BR.gap),
            w: BR.w,
            h: BR.h,
            hp: 1,
            alive: true
          });
        }
      }
    }

    // wave3以降：自動生成（適当に穴を作る＆waveで硬く）
    function makeAutoBlocks() {
      const rows = Math.min(4 + wave, 10);
      const cols = Math.min(10 + wave, 24);

      const bw = 28;
      const bh = 14;
      const gap = 4;

      const totalW = cols * (bw + gap) - gap;
      const left = (GAME_W - totalW) / 2;
      const top = 70;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (Math.random() < 0.18) continue; // 隙間
          blocks.push({
            x: left + c * (bw + gap),
            y: top + r * (bh + gap),
            w: bw,
            h: bh,
            hp: 1 + Math.floor(wave / 4),
            alive: true
          });
        }
      }
    }

    function makeBlocks() {
      blocks = [];

      const patterns = [
        // wave1: BLOCK（5行×??列） ※好きに変えてOK
        [
          "111101000011111011111010001",
          "100011000010001010000010010",
          "111101000010001010000011100",
          "100011000010001010000010010",
          "111101111101111101111010001",
        ],
        // wave2: スライム（11行×16列）
        [
          "0000011111110000",
          "0001111111111100",
          "0011111111111110",
          "0111111111111111",
          "1111100110011111",
          "1111100110011111",
          "1111111111111111",
          "0111111001111110",
          "0011111111111100",
          "0001111111111000",
          "0000011111100000",
        ],
      ];

      if (wave <= patterns.length) {
        makePatternBlocks(patterns[wave - 1]);
      } else {
        makeAutoBlocks();
      }
    }

    // =========================
    // 当たり判定
    // =========================
    function hitCircleRect(cx, cy, r, rx, ry, rw, rh) {
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx;
      const dy = cy - ny;
      return (dx * dx + dy * dy) <= r * r;
    }

    // =========================
    // ドロップ（パワー）
    // =========================
    function spawnDrop(x, y) {
      // たまに落とす
      if (Math.random() > 0.25) return;
      const types = ["WIDE", "SLOW"];
      const type = types[Math.floor(Math.random() * types.length)];
      drops.push({ x, y, w: 22, h: 22, vy: 180, type, alive: true });
    }

    function applyPower(type) {
      powerName = type;

      if (type === "WIDE") {
        paddle.w = Math.min(paddle.baseW * 1.6, 240);
        paddleBoostTimer = 7.0;
      }
      if (type === "SLOW") {
        // ボール速度を少し落とす
        for (const b of balls) {
          b.vx *= 0.8;
          b.vy *= 0.8;
        }
      }
      updateHUD();
    }

    // =========================
    // 更新
    // =========================
    function update(dt) {
      if (gameOver) return;

      // パドル（キー）
      if (!dragging) {
        const left  = keys["arrowleft"] || keys["a"];
        const right = keys["arrowright"] || keys["d"];
        if (left)  paddle.x -= paddle.speed * dt;
        if (right) paddle.x += paddle.speed * dt;
        clampPaddle();
      }

      // パワー時間減少
      if (paddleBoostTimer > 0) {
        paddleBoostTimer -= dt;
        if (paddleBoostTimer <= 0) {
          paddle.w = paddle.baseW;
          powerName = "-";
        }
      }

      // ボール
      for (const ball of balls) {
        if (!ball.alive) continue;

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // 壁反射
        if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx *= -1; }
        if (ball.x + ball.r > GAME_W) { ball.x = GAME_W - ball.r; ball.vx *= -1; }
        if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -1; }

        // 落下
        if (ball.y - ball.r > GAME_H + 60) {
          ball.alive = false;
        }

        // パドル
        if (hitCircleRect(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, paddle.h) && ball.vy > 0) {
          // 当たった場所で反射角を変える
          const hitPos = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2); // -1..1
          const angle = hitPos * 0.9; // 調整
          const speed = Math.hypot(ball.vx, ball.vy);
          ball.vx = speed * Math.sin(angle);
          ball.vy = -Math.abs(speed * Math.cos(angle));
          ball.y = paddle.y - ball.r - 0.5;
        }

        // ブロック
        for (const bl of blocks) {
          if (!bl.alive) continue;
          if (hitCircleRect(ball.x, ball.y, ball.r, bl.x, bl.y, bl.w, bl.h)) {
            // 反射（簡易：上下反転メイン）
            const prevX = ball.x - ball.vx * dt;
            const prevY = ball.y - ball.vy * dt;
            const hitFromLeft  = prevX <= bl.x - ball.r;
            const hitFromRight = prevX >= bl.x + bl.w + ball.r;
            const hitFromTop   = prevY <= bl.y - ball.r;
            const hitFromBottom= prevY >= bl.y + bl.h + ball.r;

            if (hitFromLeft || hitFromRight) ball.vx *= -1;
            else if (hitFromTop || hitFromBottom) ball.vy *= -1;
            else ball.vy *= -1;

            bl.hp -= 1;
            if (bl.hp <= 0) {
              bl.alive = false;
              kills += 1;
              score += 10; // スコアは時間じゃなく「壊した数」ベース
              spawnDrop(bl.x + bl.w/2 - 11, bl.y + bl.h/2 - 11);
              updateHUD();
            }
            break;
          }
        }
      }

      balls = balls.filter(b => b.alive);

      // ボールが全部消えたらライフ減
      if (balls.length === 0) {
        life -= 1;
        updateHUD();
        if (life <= 0) {
          gameOver = true;
        } else {
          spawnBall();
        }
      }

      // ドロップ更新
      for (const d of drops) {
        if (!d.alive) continue;
        d.y += d.vy * dt;

        // パドル取得
        if (hitCircleRect(d.x + d.w/2, d.y + d.h/2, 10, paddle.x, paddle.y, paddle.w, paddle.h)) {
          d.alive = false;
          applyPower(d.type);
        }

        // 画面外
        if (d.y > GAME_H + 30) d.alive = false;
      }
      drops = drops.filter(d => d.alive);

      // 全消しで次Wave（ここが“ウェーブごとに配置変える”場所）
      const remaining = blocks.reduce((n, b) => n + (b.alive ? 1 : 0), 0);
      if (remaining === 0) {
        wave++;
        makeBlocks();
        drops = [];

        // 次Waveはボール1個にする
        balls = [];
        spawnBall();
        updateHUD();
      }
    }

    // =========================
    // 描画
    // =========================
    function draw() {
      ctx.clearRect(0, 0, GAME_W, GAME_H);

      // 背景
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(0, 0, GAME_W, GAME_H);

      // ブロック
      for (const b of blocks) {
        if (!b.alive) continue;
        ctx.fillStyle = (b.hp >= 3) ? "#f7b" : (b.hp === 2) ? "#f55" : "#e11";
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      // ドロップ
      for (const d of drops) {
        ctx.fillStyle = (d.type === "WIDE") ? "#6cf" : "#fc6";
        ctx.fillRect(d.x, d.y, d.w, d.h);
      }

      // パドル
      ctx.fillStyle = "#aaa";
      ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

      // ボール
      for (const b of balls) {
        ctx.fillStyle = "#ddd";
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
      }

      // GameOver
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, GAME_W, GAME_H);

        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";

        ctx.font = "64px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("Game Over", GAME_W / 2, GAME_H / 2 - 10);

        ctx.font = "26px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("Tap or Press R to Restart", GAME_W / 2, GAME_H / 2 + 40);

        ctx.textAlign = "left";
      }
    }

    // =========================
    // ループ
    // =========================
    function loop(now) {
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    function restart() {
      score = 0;
      kills = 0;
      life  = 3;
      wave  = 1;
      gameOver = false;

      powerName = "-";
      paddleBoostTimer = 0;

      paddle.w = paddle.baseW;
      paddle.x = (GAME_W - paddle.w) / 2;

      drops = [];
      makeBlocks();

      balls = [];
      spawnBall();

      lastTime = performance.now();
      updateHUD();
    }

    // 起動
    restart();
    requestAnimationFrame(loop);
  </script>
</body>
</html>