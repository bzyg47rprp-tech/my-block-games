<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ブロック崩し</title>
  <link rel="icon" type="image/png" href="icon.png>
  <link rel="apple-touch-icon" href="icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="ブロック崩し">
  <style>
    :root { --w: 900px; }
    html, body { margin:0; height:100%; background:#111; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:10px; padding:12px 10px 18px; box-sizing:border-box; }
    .hud { width:min(96vw, var(--w)); display:flex; justify-content:space-between; align-items:flex-start; }
    .left, .right { display:flex; flex-direction:column; gap:4px; }
    .small { opacity:.7; font-size:14px; }
    canvas { display:block; width:min(96vw, var(--w)); height:auto; background:#0b0b0b; border:1px solid #333; border-radius:12px; touch-action:none; }
    .hint { width:min(96vw, var(--w)); opacity:.65; font-size:14px; text-align:center; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <div id="scoreText">Score: 0</div>
        <div class="small" id="infoText">Kills: 0 / Power: -</div>
      </div>
      <div class="right">
        <div id="lifeText">Life: 3</div>
        <div class="small" id="waveText">Wave: 1</div>
      </div>
    </div>

    <canvas id="game" width="800" height="600"></canvas>

    <div class="hint">操作：ドラッグ / キー。GameOver後：タップ or R</div>
  </div>

  <script>
    // =========================
    // 基本（固定座標 800x600）
    // =========================
    const GAME_W = 800, GAME_H = 600;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const scoreText = document.getElementById("scoreText");
    const infoText  = document.getElementById("infoText");
    const lifeText  = document.getElementById("lifeText");
    const waveText  = document.getElementById("waveText");

    // ぼやけ防止（DPR）
    function applyDPR(){
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      canvas.width  = Math.floor(GAME_W * dpr);
      canvas.height = Math.floor(GAME_H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    applyDPR();
    window.addEventListener("resize", applyDPR);

    // =========================
    // 状態
    // =========================
    let score = 0;
    let kills = 0;         // 壊したブロック数
    let life  = 3;
    let wave  = 1;
    let gameOver = false;

    // パワー
    let powerName = "-";
    let paddleBoostTimer = 0; // 秒
    const BOOST_SECONDS = 8;

    // パドル
    const paddle = {
      baseW: 140,
      w: 140,
      h: 14,
      x: (GAME_W - 140)/2,
      y: GAME_H - 46,
      speed: 520, // px/sec
    };

    // ボール
    let balls = []; // {x,y,r,vx,vy,alive}
    const BALL_R = 9;

    // ブロック（hp付き）
    let blocks = []; // {x,y,w,h,hp,alive}

    // アイテム（落下）
    let drops = [];  // {x,y,w,h,vy,type,alive}
    const DROP = { w: 26, h: 14, vy: 260 };

    // =========================
    // 入力：キー + ドラッグ
    // =========================
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      if (gameOver && e.key.toLowerCase() === "r") restart();
    });
    window.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

    let dragging = false;

    function canvasToWorld(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (GAME_W / rect.width);
      const y = (clientY - rect.top)  * (GAME_H / rect.height);
      return {x,y};
    }

    function movePaddleToPointer(clientX){
      const p = canvasToWorld(clientX, 0);
      paddle.x = p.x - paddle.w/2;
      clampPaddle();
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      if (gameOver) { restart(); return; }
      dragging = true;
      movePaddleToPointer(e.clientX);
    });
    canvas.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      movePaddleToPointer(e.clientX);
    });
    canvas.addEventListener("pointerup", () => dragging = false);

    // =========================
    // 便利
    // =========================
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function clampPaddle(){
      paddle.x = clamp(paddle.x, 0, GAME_W - paddle.w);
    }

    function updateHUD(){
      scoreText.textContent = `Score: ${score}`;
      infoText.textContent  = `Kills: ${kills} / Power: ${powerName}`;
      lifeText.textContent  = `Life: ${life}`;
      waveText.textContent  = `Wave: ${wave}`;
    }

    // =========================
    // ブロック生成：パターン / 自動
    // =========================
    function makePatternBlocks(pattern){
      // pattern: ["001110", "011110", ...] の配列
      blocks = [];

      const rows = pattern.length;
      const cols = pattern[0].length;

      // 画面幅に収まるように1マスのサイズを決める
      const gap = 4;
      const bw = Math.floor((GAME_W - 2*24 - gap*(cols-1)) / cols);
      const bh = 16;

      const totalW = cols * bw + gap*(cols-1);
      const left = (GAME_W - totalW)/2;
      const top  = 70;

      for (let r=0; r<rows; r++){
        const line = pattern[r];
        for (let c=0; c<cols; c++){
          if (line[c] !== "1") continue;
          blocks.push({
            x: left + c*(bw+gap),
            y: top  + r*(bh+gap),
            w: bw,
            h: bh,
            hp: 1 + Math.floor(wave/5), // waveが上がると硬く
            alive: true
          });
        }
      }
    }

    function makeAutoBlocks(){
      blocks = [];

      const rows = Math.min(4 + wave, 10);
      const cols = Math.min(8 + wave, 18);

      const gap = 4;
      const bw = 30;
      const bh = 16;

      const totalW = cols*bw + gap*(cols-1);
      const left = (GAME_W - totalW)/2;
      const top  = 70;

      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          if (Math.random() < 0.18) continue; // 隙間
          blocks.push({
            x: left + c*(bw+gap),
            y: top  + r*(bh+gap),
            w: bw,
            h: bh,
            hp: 1 + Math.floor(wave/4),
            alive: true
          });
        }
      }
    }

    function makeBlocks(){
      // wave1,2は固定パターン / wave3以降は自動
      const patterns = [
        // wave1: BLOCK（5行×29列の例。※長さを変えたら「全行の桁数」を揃えること）
        [
          "11110010000011111011111010001",
          "10001010000010001010000010010",
          "11110010000010001010000011100",
          "10001010000010001010000010010",
          "11110011111011111011111010001",
        ],
        // wave2: スライム（11行×16列）
        [
          "0000011111100000",
          "0001111111111000",
          "0011111111111100",
          "0111111111111110",
          "1111100110011111",
          "1111100110011111",
          "1111111111111111",
          "0111111001111110",
          "0011111111111100",
          "0001111111111000",
          "0000011111100000",
        ],
      ];

      if (wave <= patterns.length){
        makePatternBlocks(patterns[wave - 1]);
      } else {
        makeAutoBlocks();
      }
    }

    // =========================
    // ボール生成
    // =========================
    function spawnBall(){
      const baseSpeed = 420 + wave * 16;
      const dir = Math.random() < 0.5 ? -1 : 1;

      balls.push({
        x: paddle.x + paddle.w/2,
        y: paddle.y - 12,
        r: BALL_R,
        vx: dir * (baseSpeed * 0.45),
        vy: -baseSpeed * 0.75,
        alive: true,
      });
    }

    // =========================
    // 当たり判定
    // =========================
    function hitCircleRect(cx, cy, r, rx, ry, rw, rh){
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx;
      const dy = cy - ny;
      return (dx*dx + dy*dy) <= r*r;
    }

    // =========================
    // アイテム（ドロップ）生成/適用
    // =========================
    function maybeDrop(x, y){
      // ここで確率調整できる
      const roll = Math.random();
      let type = null;

      // 10% SPEED / 10% MULTI / それ以外なし
      if (roll < 0.10) type = "speed";
      else if (roll < 0.20) type = "multi";
      else return;

      drops.push({
        x: x - DROP.w/2,
        y: y - DROP.h/2,
        w: DROP.w,
        h: DROP.h,
        vy: DROP.vy,
        type,
        alive: true
      });
    }

    function applyPower(type){
      if (type === "speed"){
        powerName = "SPEED";
        paddleBoostTimer = 7.0;
      } else if (type === "multi"){
        powerName = "MULTI";
        // いまのボールの数を基準に、2個追加（最大6個くらいに制限）
        const add = 2;
        const maxBalls = 6;
        for (let i=0; i<add && balls.length < maxBalls; i++){
          spawnBall();
        }
      }
      updateHUD();
    }

    // =========================
    // 更新
    // =========================
    function restart(){
      score = 0;
      kills = 0;
      life  = 3;
      wave  = 1;
      gameOver = false;

      powerName = "-";
      paddleBoostTimer = 0;

      paddle.w = paddle.baseW;
      paddle.x = (GAME_W - paddle.w)/2;

      drops = [];
      makeBlocks();

      balls = [];
      spawnBall();

      lastTime = performance.now();
      updateHUD();
    }

    function loseLife(){
      life--;
      updateHUD();

      if (life <= 0){
        gameOver = true;
        return;
      }

      // ボールを1個に戻して再開
      balls = [];
      spawnBall();
    }

    function update(dt){
      if (gameOver) return;

      // パワー時間
      if (paddleBoostTimer > 0){
        paddleBoostTimer -= dt;
        if (paddleBoostTimer <= 0){
          paddleBoostTimer = 0;
          powerName = "-";
          updateHUD();
        }
      }

      // パドル操作（キー）
      const sp = paddle.speed * (paddleBoostTimer > 0 ? 1.35 : 1.0);
      if (keys["arrowleft"] || keys["a"]) paddle.x -= sp * dt;
      if (keys["arrowright"] || keys["d"]) paddle.x += sp * dt;
      clampPaddle();

      // ボール更新
      for (const ball of balls){
        if (!ball.alive) continue;

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // 壁反射
        if (ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
        if (ball.x + ball.r > GAME_W){ ball.x = GAME_W - ball.r; ball.vx *= -1; }
        if (ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }

        // 下に落ちた
        if (ball.y - ball.r > GAME_H + 30){
          ball.alive = false;
          continue;
        }

        // パドル
        if (hitCircleRect(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, paddle.h) && ball.vy > 0){
          ball.y = paddle.y - ball.r - 0.5;
          const hit = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2); // -1..1
          ball.vx = hit * 520;
          ball.vy *= -1;
        }

        // ブロック
        for (const b of blocks){
          if (!b.alive) continue;
          if (hitCircleRect(ball.x, ball.y, ball.r, b.x, b.y, b.w, b.h)){
            // 反射（簡易）
            ball.vy *= -1;

            b.hp--;
            if (b.hp <= 0){
              b.alive = false;
              kills++;
              score += 10; // 1個壊すと+10（好みで）
              updateHUD();

              // アイテム抽選（壊れた位置）
              maybeDrop(b.x + b.w/2, b.y + b.h/2);
            }
            break;
          }
        }
      }

      // 生きてるボールだけ残す
      balls = balls.filter(b => b.alive);

      // ボールが全部消えたらライフ減
      if (balls.length === 0){
        loseLife();
        return;
      }

      // ドロップ更新
      for (const d of drops){
        if (!d.alive) continue;
        d.y += d.vy * dt;

        // パドル取得
        if (hitCircleRect(d.x + d.w/2, d.y + d.h/2, Math.min(d.w,d.h)/2, paddle.x, paddle.y, paddle.w, paddle.h)){
          d.alive = false;
          applyPower(d.type);
        }

        // 画面外
        if (d.y > GAME_H + 30) d.alive = false;
      }
      drops = drops.filter(d => d.alive);

      // 全消しで次Wave
      const remaining = blocks.reduce((n, b) => n + (b.alive ? 1 : 0), 0);
      if (remaining === 0){
        wave++;
        makeBlocks();
        drops = [];

        // 次Waveはボール1個で分かりやすく
        balls = [];
        spawnBall();

        updateHUD();
      }
    }

    // =========================
    // 描画
    // =========================
    function draw(){
      ctx.clearRect(0, 0, GAME_W, GAME_H);

      // 背景
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(0, 0, GAME_W, GAME_H);

      // ブロック
      for (const b of blocks){
        if (!b.alive) continue;
        // hpで色ちょい変え（任意）
        ctx.fillStyle = (b.hp >= 3) ? "#c44" : (b.hp === 2 ? "#d66" : "#e11");
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }

      // パドル
      ctx.fillStyle = "#bbb";
      ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

      // ボール
      ctx.fillStyle = "#7fb6ff";
      for (const ball of balls){
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fill();
      }

      // ドロップ（アイテム）
      for (const d of drops){
        if (!d.alive) continue;
        ctx.fillStyle = (d.type === "speed") ? "#ffd24d" : "#7dff9a";
        ctx.fillRect(d.x, d.y, d.w, d.h);

        ctx.fillStyle = "#111";
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(d.type === "speed" ? "S" : "M", d.x + d.w/2, d.y + d.h/2 + 0.5);
      }

      // GameOver
      if (gameOver){
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, GAME_W, GAME_H);
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.font = "64px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("Game Over", GAME_W/2, GAME_H/2 - 18);
        ctx.font = "26px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("Tap or Press R to Restart", GAME_W/2, GAME_H/2 + 36);
        ctx.textAlign = "left";
      }
    }

    // =========================
    // ループ
    // =========================
    let lastTime = performance.now();
    function loop(now){
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // タップでリスタート（GameOver中）
    canvas.addEventListener("click", () => { if (gameOver) restart(); });

    // 起動
    restart();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
